AExpression = Primary [ AMessage { ';' ACascadeMessage } ]
ABinaryMessage = [ EnvSpecifier ] BinarySelector Primary [ UnaryMessages ]
ABinaryMessages = ABinaryMessage { ABinaryMessage }
ACascadeMessage = UnaryMessage | ABinaryMessage | AKeyWordMessage
AKeyWordMessage = [ EnvSpecifier | RubyEnvSpecifier ] AKeyWordPart { AKeyWordPart }
AKeyWordPart = KeyWord Primary UnaryMessages { ABinaryMessage }
AMessage = [ UnaryMessages ] [ ABinaryMessages ] [ AKeyWordMessage ]
AnyTerm = Operand [ Operator Operand ]
Array = '(' { ArrayItem } ')'
ArrayItem = Number | SymbolArrayItem | SymbolLiteral | StringLiteral |
CharacterLiteral | Array | ArrayLiteral | ByteArrayLiteral
ArrayLiteral = '#' Array
Assignment = VariableName ':=' Statement | VariableName ' _ ' Statement
BinaryMessage = [ EnvSpecifier | RubyEnvSpecifier ] BinarySelector Primary [ UnaryMessages ]
BinaryMessages = BinaryMessage { BinaryMessage }
BinaryPattern = BinarySelector VariableName
Block = '[' [ BlockParameters ] [ Temporaries ] Statements ']'
BlockParameters = { Parameter } '|'
ByteArrayLiteral = '#' '[' [ Number { Number } ] ']'
CascadeMessage = UnaryMessage | BinaryMessage | KeyWordMessage
CurlyArrayBuilder = '{' [ AExpression { '.' AExpression } ] '}'
Expression = Primary [ Message { ';' CascadeMessage } ]
KeyWordMessage = [ EnvSpecifier | RubyEnvSpecifier ] KeyWordPart {
KeyWordPart }
KeyWordPart = KeyWord Primary UnaryMessages { BinaryMessage }
KeyWordPattern = KeyWord VariableName { KeyWord VariableName }
KeyWordPragma = PragmaPair [ PragmaPair ]
Literal = Number | NegNumber | StringLiteral | CharacterLiteral |
SymbolLiteral | ArrayLiteral | SpecialLiteral | ByteArrayLiteral
Message = [ UnaryMessages ] [ BinaryMessages ] [ KeyWordMessage ]
MessagePattern = UnaryPattern | BinaryPattern | KeyWordPattern
Method = MessagePattern [ Primitive ] MethodBody
MethodBody = [ Pragmas ] [ Temporaries ] [ Statements ]
NegNumber = '-' Number
Operand = Path | Literal | Identifier
Operator = '=' | '==' | '<' | '>' | '<=' | '>=' | '~=' | '~~'
ParenStatement = '(' Statement ')'
ParenTerm = '(' AnyTerm ')'
Pragma = '< PragmaBody '>'
PragmaBody = UnaryPragma | KeyWordPragma
Pragmas = Pragma [ Pragma ]
Predicate = ( AnyTerm | ParenTerm ) { '&' Term }
Primary = ArrayBuilder | CurlyArrayBuilder | Literal | Path | Block |
SelectionBlock | ParenStatement | VariableName
Primitive = '<' [ 'protected' | 'unprotected' ] [ 'primitive:' Digits ] '>'
PragmaPair = ( KeyWordNotPrimitive | BinarySelector ) PragmaLiteral 
UnaryPragmaIdentifier = Identifier (except 'protected', 'unprotected', 'requiresVc')
PragmaLiteral = Number | NegNumber | StringLiteral | CharacterLiteral | SymbolLiteral | SpecialLiteral
SelectionBlock = '{' Parameter '|' Predicate '}'
Statement = Assignment | Expression
Statements = { [ Pragmas] { Statement '.' } } [ Pragmas ] [ ['^'] Statement ['.' [ Pragmas ] ]]
Temporaries = '|' { VariableName } '|'
Term = ParenTerm | Operand
UnaryMessage = [ EnvSpecifier ] Identifier
UnaryMessages = { UnaryMessage }
UnaryPattern = Identifier
UnaryPragma = SpecialLiteral | UnaryPragmaIdentifier